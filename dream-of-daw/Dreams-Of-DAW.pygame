#!/usr/bin/python
import os
import pygame
import platform
# from dataclasses import dataclass
from dream_of_daw.config import *
from do_daw import run, midi_note
from dream_of_daw.logger import log
from dream_of_daw.step_buttons import draw_steps_buttons
from dream_of_daw.piano import draw_piano
from dream_of_daw.channel_switch import draw_channel_switcher
from dream_of_daw.sections import draw_sections
from dream_of_daw.bottom_right import draw_bottom_right_menu
from dream_of_daw.controls import *
from functools import reduce

if "aarch64" in platform.machine():
    os.environ['HOME'] = "/userdata/system/"

THIS_DIR = os.path.dirname(os.path.abspath(__file__))
os.chdir(THIS_DIR)

pygame.init()
controller_found = False
joy = None
pygame.font.init()
fonts = [
    pygame.font.Font(f'{THIS_DIR}/Anonymous-Pro.ttf', 20),  # 0
    pygame.font.Font(f'{THIS_DIR}/Anonymous-Pro.ttf', 30),  # 1
    pygame.font.Font(f'{THIS_DIR}/Anonymous-Pro.ttf', 45),  # 2
    pygame.font.Font(f'{THIS_DIR}/Anonymous-Pro.ttf', 75),  # 3
]
clock = pygame.time.Clock()
done = False
controller = Buttons()
(stepper, mixer, _audio_wrapper) = run()

for (name, path) in mixer.get_plugin_list():
    log.info(f"found plugin: {name}, at path {path}")


def clear_screen():
    screen.fill(BACKGROUND_COLOR)


def check_controller_input(events):
    global controller

    for event in events:
        # TODO: make this a match statement
        if event.type == pygame.JOYHATMOTION:
            # controller.purge_dpad()
            match event.value:
                case (0, 0):
                    controller.purge_dpad()
                case (_, 0):
                    controller.release((0, 1))
                    controller.release((0, -1))
                case (0, _):
                    controller.release((1, 0))
                    controller.release((-1, 0))

            match event.value:
                case (_, 1):
                    controller.press((0, 1))
                    # cursor.up()
                    # log.debug("up")
                case (_, -1):
                    controller.press((0, -1))
                    # cursor.down()
                    # log.debug("down")

            match event.value:
                case (-1, _):
                    controller.press((-1, 0))
                    # cursor.left()
                    # log.debug("left")
                case (1, _):
                    controller.press((1, 0))
                    # cursor.right()
                    # log.debug("right")

            # log.debug(f"got event {event}")
        elif event.type == pygame.JOYBUTTONUP:
            controller.release(event.button)
        elif event.type == pygame.JOYBUTTONDOWN:
            controller.press(event.button)
        elif event.type == pygame.JOYAXISMOTION and event.axis == 4 and event.value > 0.0:
            controller.press(LT)
        elif event.type == pygame.JOYAXISMOTION and event.axis == 5 and event.value > 0.0:
            controller.press(RT)
        elif event.type == pygame.JOYAXISMOTION and event.axis == 4 and event.value < 0.0:
            controller.press(LT)
        elif event.type == pygame.JOYAXISMOTION and event.axis == 5 and event.value < 0.0:
            controller.press(RT)


def handle_pygame_events():
    global joy
    global controller_found

    ctrlr_events = []

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            return True
        elif event.type == pygame.JOYDEVICEADDED:
            joy = pygame.joystick.Joystick(event.device_index)
            joy.init()
            controller_found = True
            # log.debug("found controller!")
        elif event.type == pygame.JOYHATMOTION or event.type == pygame.JOYBUTTONUP or event.type == pygame.JOYBUTTONDOWN or event.type == pygame.JOYAXISMOTION:
            ctrlr_events.append(event)

    controller.step()
    if ctrlr_events:
        check_controller_input(ctrlr_events)

    if controller.is_pressed(HOME) and controller.just_released(START):
        return True

    return False


def do_nav(button, method):
    hold_time = controller.just_released(button)

    if hold_time is not None and 10 < hold_time <= 175:
        method()


def handle_nav():
    mod_key_pressed = [controller.is_pressed(
        button) is not None for button in [A, B, X, Y, HOME, START, SELECT]]
    mod_key_pressed = reduce(
        lambda acc, pressed: acc or pressed, mod_key_pressed)

    # if controller.is_pressed(A):
    #     for button, method in ((UP, cursor.up), (DOWN, cursor.down), (LEFT, cursor.left), (RIGHT, cursor.right),):
    #         do_nav(button, method)

    if mod_key_pressed:
        return

    for button, method in ((UP, cursor.up), (DOWN, cursor.down), (LEFT, cursor.left), (RIGHT, cursor.right),):
        do_nav(button, method)


def setup():
    pass


def loop():
    clear_screen()
    step_i = stepper.get_step()
    playing = stepper.is_playing()
    step_states = [stepper.get_step_state(
        CHANNEL_I, step_i) for step_i in range(16)]
    midi_notes = [step.note for step in step_states]
    note_names = [midi_note(
        step.note) if step.note is not None else None for step in step_states]
    plugins = mixer.get_plugin_names()
    section_i = stepper.get_section()

    draw_steps_buttons(fonts[1], step_i, playing, note_names)
    draw_piano(playing, step_i, midi_notes)
    draw_channel_switcher(fonts[0], CHANNEL_I, plugins)
    draw_sections(fonts[1], section_i)
    draw_bottom_right_menu(fonts[1], fonts[2], playing, stepper.get_bpm())

    handle_nav()

    pygame.display.update()


def play_chord():
    from time import sleep
    from threading import Thread

    notes = [60, 64, 67]
    # notes = [60]

    n_channels = 4

    for i in range(n_channels):
        mixer.set_instrument(i, "Wt Synth")
        mixer.play_notes(notes, i)

    # mixer.play_notes(notes, 0)

    def stop_notes():
        sleep(5)
        for i in range(n_channels):
            mixer.stop_notes(notes, i)

        log.info("done with chord")

        # mixer.stop_notes(notes, 0)
        sleep(1)

        quit_event = pygame.event.Event(pygame.QUIT)
        pygame.event.post(quit_event)

    t = Thread(target=stop_notes, daemon=True)
    t.start()

    return t


def play_arp():
    from threading import Thread

    for i in range(3):
        mixer.set_instrument(i, "Wt Synth")

    notes = [60, 64, 67, 71]
    set_note_record = [stepper.set_note(0, i, notes[i % len(notes)]) and
                       stepper.set_note(1, i, notes[i % len(notes)] - 12 + 7) and
                       stepper.set_note(2, i, notes[i % len(notes)] - 12)
                       for i in range(16)]

    def stop_notes():
        from time import sleep

        sleep(1)
        log.info(f"set notes record: {set_note_record}")
        stepper.start_playing()
        log.info("start arpegio")
        sleep(7)
        log.info("done with arp")
        sleep(1)
        stepper.stop_playing()
        sleep(1)

        quit_event = pygame.event.Event(pygame.QUIT)
        pygame.event.post(quit_event)

    t = Thread(target=stop_notes, daemon=True)
    t.start()

    return t


if __name__ == "__main__":
    from do_daw import UiSector
    # t = play_chord()
    # t = play_arp()
    cursor.sector = UiSector.Sections

    log.info("starting main loop.")
    clear_screen()
    setup()

    while not handle_pygame_events():
        loop()

    stepper.stop_playing()
    pygame.quit()
    log.info("DONE")
    log.info("GOODBYE")
